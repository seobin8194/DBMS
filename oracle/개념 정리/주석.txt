--""로 키워드를 그냥 문자열로 변경해준다

--핸드폰 번호를 숫자타입으로 저장하면 맨앞 0을 지운다 -> 문자타입으로 저장
--웹에서 왠만한 데이터는 문자열로 저징하니까 VARCHAR 이용하는게 좋다
--CLOB BLOB : 게시글같은거 저장할때 (VARCHAR2로 처리하기엔 너무 큰 데이터)
--한 셀에 저장할 데이터가 많을때 '표지훈,유승호,김하늘,박보검' 식으로 저장한다

--ID VARCHAR2(20) PRIMARY KEY -> PRIMARY KEY의 이름이 임의로 만들어지므로 CONSTRAINT 이용
--PK를 조합으로 설정 : 다중PK의 컬럼들의 값이 전부 중복되어야 PK충돌이 일어난다

--CHECK(조건식) : 테이블에 들어갈 데이터에 대한 (제약)조건 지정
                        조건 만족시 참
                        CREATE TABLE T {
                              OPENDATE DATE CHECK(OPENDATE >= TO_DATE('2000-01-01','YYYY-MM-DD'))
                        }
                        -> 테이블에 들어온 날짜 데이터가 2000-01-01이후인지 검사

--테이블 생성시 초기값을 지정 -> AGE NUMBER(2) DEFAULT 0
--DEFAULT SYSDATE : 현재 시각을 초기값으로 지정한다
--UNIQUE : 프라이머리 키는 아니지만 겹칠 수 없는 값

--컬럼명 IN (값1,값2,,) : 데이터가 값들 중 하나면 참
--컬럼명 IS (NOT)NULL : 컬럼의 값이 NULL로 비어있다면 참 / NULL이 아니면 참
--LIKE
  뒤에 오는 와일드 카드 문자열과 비교하여 같다면 참 다르면 거짓
  와일드 카드 
  _ : 한 글자 EX) '_서빈' : 3글자중에 이름이 서빈
  % : 모든 것(0글자도 포함) EX) '%서빈' : 마지막 글자가 서빈

--부모테이블 생성 -> 자식 테이블 생성
--자식테이블 삭제 -> 부모 테이블 삭제

--AND연산자가 OR연산자보다 먼저 연산된다

--컬럼에 별칭 주기
  별칭에 띄어쓰기가 있는 경우 ' '로 묶어주기
  SELECT PLAYER_NAME AS NAME, NICKNAME AS 별명 FROM PLAYER; 
--테이블에 별칭 주기
  두 테이블에서 한꺼번에 데이터를 가져올때 컬럼이 어느 테이블에 속해있는지 명시해줘야 하는데 이때 별칭을 이용한다
  곱하기되서 나온다 -> NAME하나당 모든 주소가 매치되서 나온다
  SELECT P.PLAYER_NAME, T.ADDRESS FROM PLAYER P, TEAM T;

--CASE문
CASE문은 컬럼 한개이다
CASE 
        WHEN 조전식1 THEN 값1
        WHEN 조건식2 THEN 값2
        ,,,,,,,
        ELSE 값
END
-> 조건식1 이 참이면 값1
    조건식2가 참이면 값2
     모든 조건식이 거짓이면 ELSE 뒤의 값

--시퀀스
테이블에 값이 추가될때마다 변하는 특정한 값을 미리 설계할 수 있다
시작값 증감값 종료값 최소값 최대값을 미리 설정할 수 있다
CREATE SEQUENCE 시퀀스명
START WITH 시작값
INCREMENT BY 증감값
MINVALUE 최소값
MAXVALUE 최대값
수감신청의 과목 신청 순번은 각 과목마다 시퀀스가 존재해야하므로 오라클에서 처리하기 힘들고 단일 ㅅ;퀀스를 이용하는 경우에 이용한다
시퀀스명.NEXTVAL : 현재값 사용하고 증감값만큼 변화시킨다

--ORDER BY
ORDER BY 컬럼 정렬방법
ASC 오름차순 DESC 내림차순
문자열이든 숫자든 사전 순으로 정렬

--SELECT문 실행 순서
작성시에도 이 순서로 생각하기
테이블에서 데이터 걸러주고 묶을거 묶고 묶은거에서 거르고 데이터 뽑아오고 정렬한다
FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> ORDER

--옵티마이저
SQL문을 가장 빠르소 효울적으로 수행할 최적의 처리경로를 생성해주는 DBMS 내부의 핵심 엔진
사용자가 쿼리문으로 결과를 요구하면 이를 생성하는데 필요한 처리 경로는 DBMS에 내장된 옵티마이저가 자동으로 생성한다
옵티마이저가 생성한 SQL 처리 경로를 실행계획이라고 한다

COST : 비용 예상 수행시간(쿼리를 수행하는데 일량 또는 시간)
CARDINALITY : 실행결과의 수
CARDINALITY 곱 : A   1 -> 두 테이블에서 데이터를 검색하면 카드날리티 곱 발생 -> A1 A2 A3 B1 B2 B3
                        B   2
                             3

옵티마이저의 SQL 최적화 과정
1. 사용자가 작성한 쿼리문을 수행하기 위해 실행될만한 실행계획을 갖는다
2. 데이터 딕셔너리에 미리 수집햐놓은 오브젝트 통계 및 시스템 정보로 각 실행계획의 에상 비용을 산정한다
3. 각 실행계획의 비용을 비교해서 최저 비용을 갖는 하나를 선택하고 실행

옵티마이저 종류
1. 규칙기반 옵티마이저(RBO), 휴리스틱(HEURISITIC)옵티마이저
   미리 정해진 규칙에 따라 실행
   효율성이 떨어진다
   오라클 10G 버전부터 RBO에 대한 지원중단
2. 비용기반 옵티마이저
   비용이 가장 낮은 실행계획을 실행한다

SQL문 실행 과정
PARSER                   OPTIMIZER               ROW_SOURCE_GENERATOR
문법 오류검사        총 비용 계산, 비교      실행가능 코드(컴퓨터가 알아듣는)로 변경   
코드로 변경           실행계획 생성





